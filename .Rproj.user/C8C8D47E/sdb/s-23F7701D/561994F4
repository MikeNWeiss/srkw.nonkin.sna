{
    "contents" : "Load2015Net <- function(){ #load in the 2015 whale network\n  adjacency.matrix <- as.matrix(read.csv(\"~/srkw.nonkin.sna/data/2015.adjmat.csv\", row.names=1))\n  n <- network(adjacency.matrix, directed=F) #Loads the adjacency matrix as a network\n  # add node attributes\n  n%v%\"male\" <- c('m', 'nm', 'm', 'nm', 'nm', 'm', 'nm', 'nm', 'm','m','m','m','m','m','nm','m','nm','nm','nm','nm','m','m','m','m','m')\n  n%v%\"prf\" <- c(\"nf\", \"f\", \"f\", \"nf\", \"nf\", \"nf\", \"f\", \"f\", \"f\", \"nf\", \"nf\", \"nf\", \"nf\", \"nf\", \"f\", \"nf\", \"f\",\"f\", \"nf\", \"nf\", \"nf\", \"nf\", \"nf\", \"nf\", \"nf\")\n  n%v%\"color\" <- c(\"blue\", \"red\", \"purple\", \"white\", \"white\", \"blue\", \"red\", \"red\", \"purple\", \"blue\", \"blue\", \"blue\", \"blue\", \"blue\", \"red\", \"blue\", \"red\", \"red\", \"white\", \"white\", \"blue\", \"blue\", \"blue\", \"blue\", \"blue\")\n  n%v%\"shape\" <- c(rep(1000, 7), rep(4, 5), rep(3, 13))\n  n%v%\"pod\" <- c(rep(\"J\", 7),rep(\"K\", 5), rep(\"L\", 13))\n  n%v%\"n\" <- c(3,5,6,6,3,3,1,5,7,4,2,1,6,2,1,2,9,5,3,2,1,1,1,1,1)\n  n #return the network with attributes\n}\n\nwhale.ergm <- function(net){\n  model <- ergm(net ~ edges + nodematch(\"pod\") + nodefactor(c(\"male\", \"prf\")) + gwesp(0.5, fixed=T) + isolates, control=control.ergm(MCMC.samplesize=5000, MCMC.interval=5000)) #parameter estimation for whale network\n  model\n}\n\nNetGraph <- function(net){#turn whale network into a graph object for community detection\n  g <- graph.adjacency(as.matrix(net), mode=\"undirected\") #Make the graph\n  V(g)$male <- ifelse(net%v%\"male\"==\"m\", 1, 0) #Import vertex attributes\n  V(g)$prf <- ifelse(net%v%\"prf\"==\"f\", 1, 0)\n  V(g)$n <- net%v%\"n\"\n  V(g)$pod <- net%v%\"pod\"\n  g #Return graph object\n}\n\nwhale.community.gof <- function(model, sample.size=500){ #In addition to the gof function built into the ergm package, this function was written to assess how well a model reproduces the community structure, modularity, and number of connected components in a network\n  output <- matrix(nrow=sample.size, ncol=3)\n  colnames(output) <- c(\"n.components\", \"n.communities\", \"modularity\")\n  for(i in 1:sample.size){\n    sim.net <- simulate(model)\n    sim.g <- NetGraph(sim.net)\n    comm <- optimal.community(sim.g)$membership\n    output[i, \"n.communities\"] <- max(comm) #Number of communities\n    output[i, \"modularity\"] <- modularity(sim.g, comm) #Modularity of community division\n    output[i, \"n.components\"] <- components(sim.g)$no # Number of connected Components\n  }\n  plot(density(output[,\"n.communities\"], bw=0.3), main=\"Communities\", xlab=\"n.communities\", ylab=\"density\")\n  abline(v=max(optimal.community(NetGraph(model$network))$membership))\n  plot(density(output[,\"n.components\"], bw=0.3), main=\"Components\", xlab=\"n.components\", ylab=\"density\")\n  abline(v=communities(NetGraph(model$network))$no)\n  plot(density(output[,\"modularity\"]), main=\"Modularity\", xlab=\"modularity\", ylab=\"density\")\n  abline(v=modularity(optimal.community(NetGraph(model$network))))\n}\n\nsimulate.nonkin <- function(model, reps=10000){#This function simulates from an ergm of the whale network and stores information about the types of cross-pod dyads that occur. The \"model\" argument indicates which ergm to simulate from. The \"reps\" argument defines number of simulations. The default is 10,000 simulations.\n  output <- matrix(nrow=reps, ncol=4) #Make your output matrix\n  colnames(output) <- c(\"cp.tot\", \"cp.tandem\", \"cp.m.empty\",  \"cp.m.m\") #Name your columns\n  for(i in 1:reps){\n    sim.net <- simulate(model) #Simulate from model\n    output[i,\"cp.tot\"] <- summary(sim.net~nodemix(\"pod\"))[2] + summary(sim.net~nodemix(\"pod\"))[4] + summary(sim.net~nodemix(\"pod\"))[5] #Total number of cross-pod bonds in simulated network\n    summary <- summary(sim.net~nodemix(c(\"pod\", \"prf\", \"male\"), base = c(1:10, 15, 20, 21, 26, 27, 28, 36, 44, 45, 53:55))) #Make a big summary of just cross-pod bonds\n    output[i, \"cp.tandem\"] <-  summary[7]+summary[10]+summary[15]+summary[19]+summary[21]+summary[25] #Tandem\n    output[i, \"cp.m.empty\"] <- summary[12]+summary[23]+summary[29]+summary[33] #M-Empty\n    output[i, \"cp.m.m\"] <- summary[11]+summary[22]+summary[26] #M-M\n  }\n  output #Return output matrix after all reps complete\n}\n\nsimresults.vioplot <- function(simresults){ #Plot results of simulation. simresults is a matrix produced by simulate.nonkin()\n  simresults.sub <- simresults[simresults[,\"cp.tot\"]!=0,] #Remove cases with no cross-pod ties\n  p.tandem <- simresults.sub[,\"cp.tandem\"]/simresults.sub[,\"cp.tot\"] #Porion tandem\n  p.m.empty <- simresults.sub[,\"cp.m.empty\"]/simresults.sub[,\"cp.tot\"] #Portion m.empty\n  p.m.m <- simresults.sub[,\"cp.m.m\"]/simresults.sub[,\"cp.tot\"] #Portion m.m\n  vioplot(p.tandem, p.m.empty, p.m.m, wex=0.8, col=\"grey\") #Violin plots\n  points(c(1:3), c(4/9, 4/9, 1/9), cex=1.5, col=\"red\", pch=19) #Add points corresponding to observed values\n}\n",
    "created" : 1465598739141.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2401123395",
    "id" : "561994F4",
    "lastKnownWriteTime" : 1465603530,
    "path" : "~/srkw.nonkin.sna/R/srkw.sna.code.R",
    "project_path" : "R/srkw.sna.code.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}
require(devtools)
library(srkw.nonkin.sna)
LoadNet(file.choose())
Load2015Net(file.choose())
pc.n <- Load2015Net(file.choose())
plot(pc.n)
library(srkw.nonkin.sna)
net <- Load2015Net(file.choose())
model <- whale.ergm(net)
?plot.density
library(srkw.nonkin.sna)
n <- Load2015Net(file.choose())
srkw.adjacencymatrix <- read.csv("~/Desktop/Thesis/srkw.adjacencymatrix.2015", row.names=1)
View(srkw.adjacencymatrix)
View(srkw.adjacencymatrix)
n <- Load2015Net(file.choose())
m <- whale.ergm(n)
m <- whale.ergm(n)
getwd()
View(srkw.adjacencymatrix)
write.csv(srk.adjacencymatrix, "/Users/michaelnweiss/srkw.nonkin.sna/data")
srkw.adjacecnymatrix
srkw.adjacencymatrix
write.csv(srkw.adjacencymatrix, "/Users/michaelnweiss/srkw.nonkin.sna/data")
write.csv(srkw.adjacencymatrix, "/Users/michaelnweiss/srkw.nonkin.sna")
write.csv(srkw.adjacencymatrix, "/Users/michaelnweiss/srkw.nonkin.sna/data/2015.adj.mat")
library(srkw.nonkin.sna)
Load2015Net("2015.adj.mat")
`2015.adj` <- read.csv("~/srkw.nonkin.sna/data/2015.adj.mat", header=FALSE)
View(`2015.adj`)
`2015.adj` <- read.csv("~/srkw.nonkin.sna/data/2015.adj.mat", row.names=1)
View(`2015.adj`)
Load2015Net <- function(){ #load in the 2015 whale network
n <- network(as.matrix(read.csv("~/srkw.nonkin.sna/data/2015.adj.mat", row.names=1)), directed=F)
n%v%"male" <- c('m', 'nm', 'm', 'nm', 'nm', 'm', 'nm', 'nm', 'm','m','m','m','m','m','nm','m','nm','nm','nm','nm','m','m','m','m','m')
n%v%"prf" <- c("nf", "f", "f", "nf", "nf", "nf", "f", "f", "f", "nf", "nf", "nf", "nf", "nf", "f", "nf", "f","f", "nf", "nf", "nf", "nf", "nf", "nf", "nf")
n%v%"color" <- c("blue", "red", "purple", "white", "white", "blue", "red", "red", "purple", "blue", "blue", "blue", "blue", "blue", "red", "blue", "red", "red", "white", "white", "blue", "blue", "blue", "blue", "blue")
n%v%"shape" <- c(rep(1000, 7), rep(4, 5), rep(3, 13))
n%v%"pod" <- c(rep("J", 7),rep("K", 5), rep("L", 13))
n%v%"n" <- c(3,5,6,6,3,3,1,5,7,4,2,1,6,2,1,2,9,5,3,2,1,1,1,1,1)
n
}
Load2015Net()
n<-Load2015Net()
plot(n)
library(srkw.nonkin.sna)
m <- whale.ergm(n)
Load2015Net
Load2015Net()
library(srkw.nonkin.sna)
write.csv(srkw.adjacencymatrix, "/Users/michaelnweiss/srkw.nonkin.sna/data/2015.adjmat.csv")
library(srkw.nonkin.sna)
library(srkw.nonkin.sna)
n <- Load2015Net()
library(srkw.nonkin.sna)
n <- Load2015Net()
`2015.adjmat` <- read.csv("~/srkw.nonkin.sna/data/2015.adjmat.csv", row.names=1)
View(`2015.adjmat`)
library(srkw.nonkin.sna)
n <- Load2015Net()
library(srkw.nonkin.sna)
Load2015Net()
n<-Load2015Net()
plot(n)
m <- whale.ergm(n)
whale.community.gof(m)
optimal.community(NetGraph(n))
components(NetGraph(n))$no
whale.community.gof <- function(model){ #In addition to the gof function built into the ergm package, this function was written to assess how well a model reproduces the community structure, modularity, and number of connected components in a network
output <- matrix(nrow=500, ncol=3)
colnames(output) <- c("n.components", "n.communities", "modularity")
for(i in 1:500){
sim.net <- simulate(model)
sim.g <- NetGraph(sim.net)
comm <- optimal.community(sim.g)$membership
output[i, "n.communities"] <- max(comm) #Number of communities
output[i, "modularity"] <- modularity(sim.g, comm) #Modularity of community division
output[i, "n.components"] <- components(sim.g)$no # Number of connected Components
}
par(mfrow=c(1,3))
hist(output[,"n.communities"], main="Communities", xlab="n.communities", ylab="density")
abline(v=5)
hist(output[,"n.components"], main="Components", xlab="n.components", ylab="density")
abline(v=3)
hist(output[,"modularity"], main="Modularity", xlab="modularity", ylab="density")
abline(v=0.64)
}
whale.community.gof(m)
whale.community.gof <- function(model){ #In addition to the gof function built into the ergm package, this function was written to assess how well a model reproduces the community structure, modularity, and number of connected components in a network
output <- matrix(nrow=500, ncol=3)
colnames(output) <- c("n.components", "n.communities", "modularity")
for(i in 1:500){
sim.net <- simulate(model)
sim.g <- NetGraph(sim.net)
comm <- optimal.community(sim.g)$membership
output[i, "n.communities"] <- max(comm) #Number of communities
output[i, "modularity"] <- modularity(sim.g, comm) #Modularity of community division
output[i, "n.components"] <- components(sim.g)$no # Number of connected Components
}
par(mfrow=c(1,3))
plot(density(output[,"n.communities"], bw=0.5), main="Communities", xlab="n.communities", ylab="density")
abline(v=5)
plot(density(output[,"n.components"], bw=0.5), main="Components", xlab="n.components", ylab="density")
abline(v=3)
plot(density(output[,"modularity"]), main="Modularity", xlab="modularity", ylab="density")
abline(v=0.64)
}
whale.community.gof(m)
whale.community.gof <- function(model, sample.size=500){ #In addition to the gof function built into the ergm package, this function was written to assess how well a model reproduces the community structure, modularity, and number of connected components in a network
output <- matrix(nrow=sample.size, ncol=3)
colnames(output) <- c("n.components", "n.communities", "modularity")
for(i in 1:sample.size){
sim.net <- simulate(model)
sim.g <- NetGraph(sim.net)
comm <- optimal.community(sim.g)$membership
output[i, "n.communities"] <- max(comm) #Number of communities
output[i, "modularity"] <- modularity(sim.g, comm) #Modularity of community division
output[i, "n.components"] <- components(sim.g)$no # Number of connected Components
}
par(mfrow=c(1,3))
plot(density(output[,"n.communities"], bw=0.8), main="Communities", xlab="n.communities", ylab="density")
abline(v=5)
plot(density(output[,"n.components"], bw=0.8), main="Components", xlab="n.components", ylab="density")
abline(v=3)
plot(density(output[,"modularity"]), main="Modularity", xlab="modularity", ylab="density")
abline(v=0.64)
}
whale.community.gof(m)
m$network
optimal.community(NetGraph(n))
optimal.community(NetGraph(n))$no
optimal.community(NetGraph(n))$membership
max(optimal.community(NetGraph(n))$membership)
modularity(optimal.community(NetGraph(n)))
library(srkw.nonkin.sna)
n <- Load2015Net
m <- whale.ergm(n)
n
plot(n)
Load2015Net <- function(){ #load in the 2015 whale network
adjacency.matrix <- as.matrix(read.csv("~/srkw.nonkin.sna/data/2015.adjmat.csv", row.names=1))
n <- network(adjacency.matrix, directed=F) #Loads the adjacency matrix as a network
# add node attributes
n%v%"male" <- c('m', 'nm', 'm', 'nm', 'nm', 'm', 'nm', 'nm', 'm','m','m','m','m','m','nm','m','nm','nm','nm','nm','m','m','m','m','m')
n%v%"prf" <- c("nf", "f", "f", "nf", "nf", "nf", "f", "f", "f", "nf", "nf", "nf", "nf", "nf", "f", "nf", "f","f", "nf", "nf", "nf", "nf", "nf", "nf", "nf")
n%v%"color" <- c("blue", "red", "purple", "white", "white", "blue", "red", "red", "purple", "blue", "blue", "blue", "blue", "blue", "red", "blue", "red", "red", "white", "white", "blue", "blue", "blue", "blue", "blue")
n%v%"shape" <- c(rep(1000, 7), rep(4, 5), rep(3, 13))
n%v%"pod" <- c(rep("J", 7),rep("K", 5), rep("L", 13))
n%v%"n" <- c(3,5,6,6,3,3,1,5,7,4,2,1,6,2,1,2,9,5,3,2,1,1,1,1,1)
n #return the network with attributes
}
n <- Load2015Net()
plot(n)
m <- whale.ergm(n)
whale.community.gof(m)
fastgreedy.community(NetGraph(n))
results <- simulate.nonkin(m, 200)
simulate.nonkin <- function(model, reps){#This function simulates from an ergm of the whale network and stores information about the types of cross-pod dyads that occur. The "model" argument indicates which ergm to simulate from. The "reps" argument defines number of simulations
output <- matrix(nrow=reps, ncol=4) #Make your output matrix
colnames(output) <- c("cp.tot", "cp.tandem", "cp.m.empty") #Name your columns
for(i in 1:reps){
sim.net <- simulate(model) #Simulate from model
output[i,"cp.tot"] <- summary(sim.net~nodemix("pod"))[2] + summary(sim.net~nodemix("pod"))[4] + summary(sim.net~nodemix("pod"))[5] #Total number of cross-pod bonds in simulated network
summary <- summary(sim.net~nodemix(c("pod", "prf", "male"), base = c(1:10, 15, 20, 21, 26, 27, 28, 36, 44, 45, 53:55))) #Make a big summary of just cross-pod bonds
output[i, "cp.tandem"] <-  summary[7]+summary[10]+summary[15]+summary[19]+summary[21]+summary[25] #Tandem
output[i, "cp.m.empty"] <- summary[12]+summary[23]+summary[29]+summary[33] #M-Empty
output[i, "cp.m.m"] <- summary[11]+summary[22]+summary[26] #M-M
}
output #Return output matrix after all reps complete
}
results <- simulate.nonkin(m, 200)
simulate.nonkin <- function(model, reps){#This function simulates from an ergm of the whale network and stores information about the types of cross-pod dyads that occur. The "model" argument indicates which ergm to simulate from. The "reps" argument defines number of simulations
output <- matrix(nrow=reps, ncol=4) #Make your output matrix
colnames(output) <- c("cp.tot", "cp.tandem", "cp.m.empty",  "cp.m.m") #Name your columns
for(i in 1:reps){
sim.net <- simulate(model) #Simulate from model
output[i,"cp.tot"] <- summary(sim.net~nodemix("pod"))[2] + summary(sim.net~nodemix("pod"))[4] + summary(sim.net~nodemix("pod"))[5] #Total number of cross-pod bonds in simulated network
summary <- summary(sim.net~nodemix(c("pod", "prf", "male"), base = c(1:10, 15, 20, 21, 26, 27, 28, 36, 44, 45, 53:55))) #Make a big summary of just cross-pod bonds
output[i, "cp.tandem"] <-  summary[7]+summary[10]+summary[15]+summary[19]+summary[21]+summary[25] #Tandem
output[i, "cp.m.empty"] <- summary[12]+summary[23]+summary[29]+summary[33] #M-Empty
output[i, "cp.m.m"] <- summary[11]+summary[22]+summary[26] #M-M
}
output #Return output matrix after all reps complete
}
results <- simulate.nonkin(m, 200)
simresults.vioplot(results)
results$cp.tot
simresults.vioplot <- function(simresults){ #Plot results of simulation. simresults is a matrix produced by simulate.nonkin()
simresults.sub <- simresults[simresults[,"cp.tot"]!=0,] #Remove cases with no cross-pod ties
p.tandem <- simresults.sub[,"cp.tandem"]/simresults.sub[,"cp.tot"] #Porion tandem
p.m.empty <- simresults.sub[,"cp.m.empty"]/simresults.sub[,"cp.tot"] #Portion m.empty
p.m.m <- simresults.sub[,"cp.m.m"]/simresults.sub[,"cp.tot"] #Portion m.m
vioplot(p.tandem, p.m.empty, p.m.m, wex=0.8, col="grey") #Violin plots
points(c(1:3), c(4/9, 4/9, 1/9), cex=1.5, col="red", pch=19) #Add points corresponding to observed values
}
simresults.vioplot(results)
require(vioplot)
simresults.vioplot(results)
par(mfrow=c(1,1))
simresults.vioplot(results)
library(srkw.nonkin.sna)
require(devtools)
require(devtools)
